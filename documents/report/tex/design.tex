\section{Methodology}
\section{System Architecture}
	\subsection{Network Simulation}
		\subsubsection{Fundamental Structure}
		\subsubsection{Environment}
		\subsubsection{Application Programming Interfaces (API)}
	\subsection{Communications Routing}

The simulator itself should not prescribe a set way of performing communications routing, rather it is up to the user to specify the routing algorithm they wish to use. This needs to be done in a way which makes it easy to specify different routing algorithms for different nodes in a simulation, i.e. there is not a set algorithm for each simulation. This is useful, for example, if one wishes to simulate a network of quadcopters backed up by a series of stationary nodes on the ground. It should also be possible to package, distribute, and import implementations for different communications algorithms.

Starting with the first problem, that is the ability to specify different routing algorithms for different nodes in the same simulation, it is clear that the specification of the routing protocol should apply to individual nodes rather than to simulations. To this end, it was decided to break out the communications functions for each node to a separate communications module. This provides a level of abstraction for messageable programs, as they can then make use of generic send and receive functions at the application level of the OSI model, while the communications module has fine grain control over the networking layer. In more practical terms, each messageable must have a communication module associated with it at instantiation, and it is this object that will be called when the unit wishes to send and receive messages. Another benefit of this approach is that it allows flexibility when designing communications modules - it is possible to either have every node in the simulation use the same communications object, or for each node to use its own separate communications object.

When considering the second problem mentioned above concerning the packaging, distribution, and importing of routing functions, it was determined that this could be best achieved by combining collections of implementations into libraries and allowing the user to select these libraries as appropriate when writing a drone program. This makes it easy to mix and match different algorithms from different sources, and means that in order to use a particular approach, one need only link their program against the appropriate communications library. It also allows different contributors to use identical or overlapping namespaces.

It is also necessary to determine exactly what responsibilities a communications module has, as well as the interface it should expose to its messageable. The most obvious function required of a component designed to communicate is to send information. To this end the communication module must be able to take a message and broadcast it to other nodes in the network. Exactly how this is achieved is dependant on the routing algorithm involved, but it is expected that most implementations will receive a message from the messageable, do some intermediate processing (perhaps to determine the best route to take) and then call the environment function to pass the message to hardware (be that real or simulated).

If we are able to send messages via a communications module then it stands to reason that we should also be able to receive messages through it. Thus, there must also be a way for the communications module to transfer messages it has received to its messageable. This can be achieved by providing a callback function to the environment, which can be invoked when there is a message to deliver. An alternative method which instead provides asynchronous message passing is for each communications module to have a queue of incoming messages for it to process, which it should check at regular intervals. Both of these messages have merit, given that interrupt driven message delivery can become problematic when the network is flooded with messages (no other tasks can be done as the message interrupt is constantly called over routine code), and the asynchronous approach can lead to problems when it is paramount that a message be delivered immediately (such as a command to ground a malfunctioning quadcopter).

The module also needs some way of performing tasks which are not triggered by the arrival of new messages. In order to facilitate time or state driven processing, communications modules need to have a function which is run independently of the send/receive functions and either loops or is called continuously. It is also clear that one should be able to trigger the pushing out or pulling in of messages from this function, to allow for the use of non-data packets (perhaps, again, to determine the optimum route to the destination).

But if the above function is to be run as a loop, the must be some condition upon which it terminates, lest the simulation run indefinitely. If the threads a messageable and its communication object were associated with each other then it would be possible to terminate both when the program exited. This could also be achieved by having the program notify the communications module that execution is complete and that it should terminate. The latter option was chosen due to the fact that it simplified the construction of the simulator, and made it easier to modify the relationship between messageable objects and communications modules, for example to change the relationship from one to one to one to many (so that a base station could have separate communication interfaces to other stationary nodes and to aerial units).  
		
	\subsection{Physical Routing} 
	\subsection{Physical Deployment}
		\subsubsection{Libraries}