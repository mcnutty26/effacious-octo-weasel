\label{projeval}

\emph{The aim of the project was to create a generic simulation for drone networks which was capable of being extensible to a variety of different UAV hardware, and to prove its effectiveness on the specific use case of the Parrot AR drone by bridging the gap between the simulation and the hardware. This chapter will evaluate the success of the project against the original requirements, including a summary of the results of creating the simulator, the implementation of routing, and the transition to physical deployment. It will also give a summary of how the project scheduling performed compared to the projected schedule, and make suggestions as to how the project could have been extended given a larger timeframe.}

\section{Project Deliverables}

\subsection{Simulator}
One of the biggest challenges to creating the simulator was the decision to migrate from the core functionality provided by ns-3, and instead focus on creating a simulator from the ground up. As a result of research and testing, it was found that ns-3 was too bloated and rigid to create an efficient, general-purpose simulation for drone sensor networks. In place of using a pre-existing library for network simulation, it was decided that the simulator would be built using C++ from first principles. The design and development of the simulator was incredibly successful; despite concerns that the simulator would not be able to accurately reflect a real environment given the size of the workload and the scope of the project, the simulator was capable of initialising a drone sensor network with all of the functionality which was expected of it. Features of the simulator include the ability to create a network environment, instantiate drones (messageable objects), install communications modules on them such that drones (and the base station) can communicate, pass messages based on arbitrary communications protocols, and visualisation of the simulation itself. As the aim was to create a fully functional simulator which could be used to model arbitrary sensor networks, the simulator demonstrates all of the necessary components for the task.
		\subsection{Routing}
In order to ensure that the simulation performed as expected, it had to be capable of effectively modelling communications algorithms and the ability for each node to control its own individual airspace. Additionally, it was necessary for the simulation to be capable of selecting which communications routing protocol to use at runtime, such that the simulation could be generic enough to incorporate any algorithm. This allows the end user to select the optimal algorithm to model the desired environment in terms of energy efficiency, computation time and complexity. For the implementation of physical routing, methods for collision detection and governing airspace were to be defined in the simulator, such that each drone would be able to carry out its own flightplan autonomously, which included calculating a priority in order to resolve potential collisions. Overall, both communications and physical routing were accurately represented in the simulation, and the demonstration simulation reflected the requirements of the design. Physical routing was not as complex as originally intended, as it did not include specific algorithms for pathing, which may have added to the versatility of the simulation.
\subsection{Physical Deployment}
Physical deployment was necessary in order to prove that the simulation could be accurately reflected in the hardware, providing a general use case for the simulation to adapt to. The main tasks for physical deployment included ensuring that the hardware, especially with regards to the peripherals for the drone, could be used correctly, that the simulator could be adapted to the library selected for hooking into the drone, and that the code could be transferred over to the external computer which was attached to the drone. Provided that the simulator accurately modelled real deployment, the assumption was that the code did not have to be re-factored for the sake of deployment. While there were some difficulties with transferring the code over to the Raspberry Pi, the library used for controlling the drone’s physical movements was sufficiently tested, and the drones actually performed according to the simulation which was built to demonstrate a real drone sensor network. Despite concerns about the weight of the drone, the peripherals were sufficiently light, and did not affect the flight of the drone.
	\section{Time Management}
Following the initial planning stages of the project, the group created a Gantt chart in order to schedule the tasks which had to be completed and the amount of time allotted to each task. For example, the design of the simulation environment was to be completed by week 10 of term one. Unfortunately, this schedule was too optimistic and did not reflect the allowances which had to be made for deadlines relating to each group member’s individual work. Each group member had several coursework deadlines scheduled for the end of the first term. As a result, development did not begin until the beginning of the second term; contingency time was allotted to allow for any delays or changes to requirements, and the holiday was able to be used as a buffer for finalisation of the design stage. In order to compensate for lost time, the frequency of group meetings and collaborative coding sessions was increased, and tasks such as communications and physical routing were performed concurrently.
The project was able to progress according to schedule during the second term, as research and development, including the group project report, continued unabated until the final weeks of the term. During this time, the group focused on completing the design for the visualisation of the simulation, the implementation of communications protocols following research, and preparing the drones for physical deployment by testing the hardware and the library which would be used to pipe the simulation framework to the drone itself. The visualisation process was found to be more difficult than expected, and was not fully completed until the beginning of the third term. Nonetheless, the group did not require any extensions for deadlines and successfully delivered the project within time constraints, with minimal changes to requirements and scheduling.
	\section{Requirements Evaluation}
In the specification chapter of the report, the functional and non-functional requirements were carefully established, such that the success of the project could be measured against the utilities which were intended for it.  While it is difficult to measure non-functional requirements in terms of success, most of the core functionality such as sending, listening for, and receiving messages over Wi-Fi or radio can be seen in the simulation. The simulation code was shown to be adaptable to the physical drones for real deployment, and the extensibility of the code as a non-functional requirement can be seen from the results of the simulation demonstration. Additionally, the functional requirements of the project do not provide an exhaustive list of the features contained within the project software, as there are many other features such as simulation timing objects for time-based events which were also included in the simulation. Given that the project is not marketable and that the stakeholders can be identified but not consulted with, it is also difficult to ensure that the project software meets requirements which have not been established by the group. 
Some of the requirements for the projects were not met due to time constraints, and some requirements were adjusted to reflect the status of the project as it progressed. For example, one of the key features which was intended for the project was the ability to implement user input-tasking, where the user could specify a job for the network to carry out. While it is possible to show that the simulation can be extended to the hardware and adapted to any arbitrary task without performing the task explicitly, the project did not progress to a state where a specific demonstration could be shown of the network receiving a task from the user to complete using sensory information and carrying it out. Another functional requirement was the ability of the nodes to move through the environment using pathfinding algorithms chosen at runtime, similarly to communications routing. The drones are capable of moving through the environment by managing their own airspace, but they lack the implementation of more complex, efficient physical routing protocols, and there are no alternatives to the current implementation. However, the lack of these features does not detract from the completeness of the solution, and a result of agile development is simply that the requirements continue to change to reflect the state of the project.
	\section{Future Work}
There are many possible extensions and improvements to the project which could have been implemented, which would have been examined given a larger timescale. In particular, there were many ideas with regards to improving the efficiency of the simulator, improving the API, and adding more communications and physical routing libraries to the system.
The simulation environment is the core of the project software, and one of the biggest problems is the current runtime, which has the potential to be optimised, as discussed in section 6.2. Within the environment, it would be possible to improve the broadcasting function which currently tests the entire list of messageables. This could be improved by attempting to limit the number of messageables to those within the immediate vicinity of the broadcast through segmentation of the environment, which would greatly reduce the overheads involved in checking each messageable object. Another potential extension with regards to the simulator is the upkeep function of the drones, which currently called upkeep one drone at a time, which causes dependencies between drones. This process could be made more efficient by parallelising the upkeep function (in the case of a system that can handle a large amount of threads).
In order to improve the functionality of the simulator, the number of communications routing libraries could also be increased to provide more variety in modelling the environment. The current simulator only supports the Basic messaging protocol as well as routing based on AODV. As a result, the end user who wishes to model the system may find that it is difficult to find the optimal routing protocol for their specific use case. Adding more routing protocols such as DSR would allow for more options when modelling the environment, which would likely allow the user to improve the accuracy of the their network environment by finding the most suitable algorithm. In addition to communications routing, the current simulator code only performs physical routing by allowing each drone to manage its own airspace and avoid collisions. While the basic method of movement and avoiding collision allows for a sensor network to be modelled accurately, it may not reflect the needs of the user and could be further optimised with the use of other existing pathfinding algorithms.
On the note of the end user, it is also important for the simulator to be user-friendly, such that the functions which need to be used to tailor the stimulator to specific hardware are easy to use and understand. Currently, the API is not very readable; it is quite difficult to see which functions are supposed to be used and how. In order to improve the experience for the user, the simulator could be improved by adding prefixes for functions, so that they are more visible, or by adding another level of inheritance to the tree, which would simplify the architecture and make it more secure for the user.
With regards to physical deployment, the project has only implemented a specific use case involving the Parrot AR 2.0 Power Edition drone. In order to aid in the generic nature of the simulation and foster a more complete solution, the simulator could be adapted to more cases using different hardware. In doing so, errors which are specific to the Parrot drone could be highlighted, as well as overcoming issues related to hardware other than the Parrot which have yet to be seen. By attempting deployment on different hardware, the simulator can be shown to be portable to more than one platform and thus capable of being adapted to any arbitrary hardware. While the team envisioned the ability to extend the project software to multiple platforms, this was practically unrealistic given the budget of the project. 

All in all the reference deployment of octoDrone was a great success. The final version of the parrot library was able to take simulator programs and run them on hardware with no changes and simulation files were usable with minimal changes. The quadcopters performed very similarly to our simulations, which simultaneously validates the accuracy of both the simulator and the deployment.

Running distributed applications on the Raspberry Pi was made extremely easy by having the compiled simulation take care of starting and stopping any additional threads it needed to create. This ease of use was such that it piqued the interest of a number of faculty who identified it as being an excellent outreach resource.

The results we managed to achieve also highlight how easy it would be to create a similar implementation for another hardware setup. In theory, it may also be possible to create a simulation which ran on a mixture of simulated and real drones. 